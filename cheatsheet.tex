\documentclass[10pt,landscape]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[landscape]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{minted}

\pdfinfo{
  /Title (Python3 CheatSheet)
  /Creator (TeX)
  /Producer (pdfTeX 1.40.0)
  /Author (Quentin Dufour)
  /Subject (python)
  /Keywords (python)}

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
    { \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
    {\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
        {\geometry{top=1cm,left=1cm,right=1cm,bottom=1cm} }
    }

% Turn off header and footer
\pagestyle{empty}

% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%x
                                {\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                {-1explus -.5ex minus -.2ex}%
                                {0.5ex plus .2ex}%
                                {\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                {-1ex plus -.5ex minus -.2ex}%
                                {1ex plus .2ex}%
                                {\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}

%My Environments
\newtheorem{example}[section]{Example}
% -----------------------------------------------------------------------

\begin{document}
\raggedright
\footnotesize
\begin{multicols}{3}


% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
\setlength{\premulticols}{1pt}
\setlength{\postmulticols}{1pt}
\setlength{\multicolsep}{1pt}
\setlength{\columnsep}{2pt}

\begin{center}
     \Large{\underline{Python 3.x}} \\
\end{center}

\section{Structures}

Une classe

\begin{minted}{python}
class Dog(Animal):
  def __init__(self):
    # ...

  def hello(self):
    # ...
\end{minted}

Une fonction

\begin{minted}{python}
def ma_fonction(arg1, arg2):
  return 3
\end{minted}

Les conditions

\begin{minted}{python}
if a == b:
  # faire quelque chose
elif b == c:
  # autre chose
else:
  # encore autre chose
\end{minted}

Les conditions ternaires

\begin{minted}{python}
a = 5 if c == b else 8
# Si c == b, a = 5 sinon 8
\end{minted}

Gestion des exceptions

\begin{minted}{python}
try:
  # quelque chose
except:
  # autre chose
\end{minted}

\section{Conversions}

Conversion entiers / chaines de caractères

\begin{minted}{python}
int("1853") * 2 # 3706
str(1853) * 2   # "18531853"
\end{minted}

\section{Initialisations}

Initialiser une liste 6 éléments à 3
\begin{minted}{python}
l = [3,]*6
# [3, 3, 3, 3, 3, 3]
\end{minted}

Initialiser 4 variables à None
\begin{minted}{python}
a,b,c,d = (None,)*4
# a=None, b=None, c=None, d=None
\end{minted}

Générer une liste de carrés
\begin{minted}{python}
[i**2 for i in range(1,6)]
# Genere [1, 4, 9, 16, 25]
\end{minted}

Générer un tableau 2D (une matrice) de 2 par 3 à -1

\begin{minted}{python}
[[-1 for x in range(2)] for y in range(3)]
# [[-1, -1],
#  [-1, -1],
#  [-1, -1]]
\end{minted}

\section{Iterables}

Tout les exemples sont présentés avec une chaine de caractère mais fonctionnent également avec une liste ou d'autres iterables.

Itérer sur les charactères d'une liste
\begin{minted}{python}
for carac in "hello world":
  print(carac, end="-")
# h-e-l-l-o- -w-o-r-l-d-
\end{minted}

Accéder à des caractères d'une liste
\begin{minted}{python}
"hello world"[2]  # 3eme element "l"
"hello world"[-1] # dernier element "d"
\end{minted}

Accéder à des sous chaines de caractère
\begin{minted}{python}
chaine = "hello world"
chaine[1:5]   # "ello"
chaine[-5:-1] # "worl"
chaine[-5:]   # "world"
chaine[4:]    # "o world"
\end{minted}

Inverse la chaîne de caractère
\begin{minted}{python}
chaine[::-1] # "dlrow olleh"
\end{minted}

\section{Listes}

Ajout et concaténation
\begin{minted}{python}
[1, 2, 3].append(4)   # [1, 2, 3, 4]
[1, 2] + [3, 4]       # [1, 2, 3, 4]

a = [1, 2]
a += [3, 4]
a.extend([5, 6])
a.append(7)
# a = [1, 2, 3, 4, 5, 6, 7]
\end{minted}

Associer plusieurs listes
\begin{minted}{python}
zip([1, 2, 3], [4, 5, 6])
# [(1, 4), (2, 5), (3, 6)]
\end{minted}

Récupérer l'index d'un élément

\begin{minted}{python}
["foo", "bar", "baz"].index("bar")
# 1
\end{minted}

\section{Chaines de caractères}

Conversion code ASCII / caractère
\begin{minted}{python}
chr(97)  # 'a'
ord('a') # 97
\end{minted}

\section{Dictionnaire}

Vérifier l'existence d'une clé
\begin{minted}{python}
dic = {"a": 1}
if "a" in dic:
  # Verifie si la clef a existe
  pass
\end{minted}

Itérer sur un dictionnaire
\begin{minted}{python}
dic = {"a": 1, "b": 2}
for cle, valeur in dic.items():
  print(cle, valeur)
\end{minted}

\section{Tuple}

Tuple packing et unpacking
\begin{minted}{python}
t = 12345, 54321, 'hello!'
x, y, z = t
\end{minted}

Cas particuliers (Tuple de 0 et 1 élément)
\begin{minted}{python}
empty = ()
singleton = 'hello',
# notez la derniere virgule
\end{minted}

\section{Set}

Un set ne contient qu'une seule fois chaque valeur et n'est pas ordonné.
\begin{minted}{python}
{8, 9, 9, 1}
# {9, 8, 1}
\end{minted}

\section{Entrées / Sorties}

Pour lire une ligne sur l'entrée standard :

\begin{minted}{python}
input() # stdin
\end{minted}

Pour lire sur l'entrée standard jusqu'à un EOF (End Of File) :

\begin{minted}{python}
import sys

for line in sys.stdin:
  print(line)
\end{minted}

\textit{Vous pourrez alors executer votre application avec "python3 monapp.py < fichier.txt" ou "python3 monapp.py" et écrire ce que vous voulez puis terminer par un CTRL + D}

Pour écrire sur la sortie standard :

\begin{minted}{python}
print(x, y, z) # print sur stdout
print("fatal error", file=sys.stderr)
# print sur stderr
\end{minted}

\section{Fonctionnel}

Réduction (reduce)

\begin{minted}{python}
from functools import reduce
reduce(lambda x, y: x*y, [2, 3, 4])
# 2 * 3 * 4 = 24
\end{minted}

Filtre (filter)
\begin{minted}{python}
list(filter(lambda x: x > 2, [1,2,3,4]))
# [3, 4]

[n for n in [1, 2, 3, 4] if n > 2]
# [3, 4]
\end{minted}

Association (map)
\begin{minted}{python}
list(map(lambda x: x**2, [2, 3, 4]))
# [4, 9, 16]

[n**2 for n in [2, 3, 4]]
# [4, 9, 16]
\end{minted}

\section{Mathématiques}

Récupérer le minimum ou le maximum de plusieurs valeurs.
\begin{minted}{python}
min(3, 5)       # 3
min(3, 2, 8, 7) # 2
min([13, 5, 8]) # 5
max(6, 3)       # 3
...
\end{minted}

A la puissance n
\begin{minted}{python}
i, n = (3, 2)
i ** n    # 9
pow(i, n) # 9
\end{minted}

Valeur absolue
\begin{minted}{python}
abs(-5) # 5
\end{minted}

\section{Tri}

Retourner une nouvel iterable trié
(Fonctionne avec tout iterable)
\begin{minted}{python}
sorted([9,12,2])
# [2, 9, 12]

sorted({"F": 0, "D": 0, "A": 0, "B": 0})
# ['A', 'B', 'D', 'F']

sorted([9,12,2], reverse=True)
# [12, 9, 2]
\end{minted}

Trier une liste (seulement)
\begin{minted}{python}
a = [5, 2, 8]
a.sort()
# a = [2, 5, 8]
\end{minted}

%\section{Solveurs}

\section{Threads et Queue}

\begin{minted}{python}
from Queue import Queue
from threading import Thread

def listener(q):
  while True:
    print(q.get())

q = Queue()
t = Thread(target=listener, args=(q))

t.start()
q.put("hello")
\end{minted}

\section{Réseau}

\begin{minted}{python}
import socket, select

sock = socket.socket( \
  socket.AF_INET, \
  socket.SOCK_STREAM)
rlist = []

sock.bind(('0.0.0.0', 1025))
sock.listen()

while True:
  rd, wr, err = select.select(rlist, [], [])
  for s in rd:
    if s is sock:
      client_socket, address = sock.accept()
      rlist.append(client_socket)
    else:
      data = s.recv(1024)
      if data: print(data); sock.send("OK")
      else: s.close(); rlist.remove(s)
\end{minted}

\section{HTTP}
\url{http://flask.pocoo.org/docs/0.11/quickstart/}

Créer un dossier /static pour servir des fichiers.

Créer un dossier /templates pour mettre les templates au format JINJA2.

\begin{minted}{python}
<h1>{{ name }} </h1>
\end{minted}

Code d'exemple avec Flask

\begin{minted}{python}
from flask import Flask, request, \
        render_template, url_for, session
app = Flask(__name__)

@app.route("/user")
@app.route("/user/<username>", \
        methods=['GET', 'POST'])
def hello(username=None):
    if request.method == 'POST':
        # request.form['hello']
        # session['username'] = xx
        return render_template( \
        'hello.html', name=username)
    else:
        return "Hello "+username+" !"

app.run()

\end{minted}

\section{Stocker données}

TODO

\section{Hash et encodage}

base64

md5

hash

\section{Programmation dynamique}

Deux méthodes "systématiques":

1. Librairie standard
\begin{minted}{python}
from functools import lru_cache
...
# max_size le nombre d'elements max
# du cache ou None (cache "infini")
@lru_cache(max_size=42)
def anything(*args):
....
\end{minted}

2. homemade
\begin{minted}{python}
from collections import defaultdict
def dynamic(f):
    cache = defaultdict(lambda:-1)
    def is_known(*args):
        if cache[args] == -1:
            cache[args] = f(*args)
        return cache[args]
    return is_known

@dynamic
def anything(*args):
    ....
\end{minted}

\section{La bissection - dichotomie}

% http://stackoverflow.com/questions/14392208/how-to-do-the-bisection-method-in-python
\begin{minted}{python}
def bisect(func, low, high, desired, iter):
    for i in range(iter):
        midpoint = (high - low) / 2.0 + low
        if func(midpoint) > desired:
            high = midpoint
        else:
            low = midpoint

    return midpoint
\end{minted}

\section{Union Find}

% http://code.activestate.com/recipes/577225-union-find/
\begin{minted}{python}
def MakeSet(x):
     x.parent = x
     x.rank   = 0

def Union(x, y):
     xRoot = Find(x)
     yRoot = Find(y)
     if xRoot.rank > yRoot.rank:
         yRoot.parent = xRoot
     elif xRoot.rank < yRoot.rank:
         xRoot.parent = yRoot
     elif xRoot != yRoot: 
         yRoot.parent = xRoot
         xRoot.rank = xRoot.rank + 1

def Find(x):
     if x.parent == x:
        return x
     else:
        x.parent = Find(x.parent)
        return x.parent


class Node:
    def __init__ (self, label):
        self.label = label
    def __str__(self):
        return self.label

l = [Node(ch) for ch in "abcdefg"]
[MakeSet(node) for node in l]
Union(l[0],l[2])
sets = [str(Find(x)) for x in l]
\end{minted}

\section{Segment Tree}

% http://www.learn4master.com/algorithms/range-minimum-query-segment-tree
\begin{minted}{python}
def buildTree(root, Tree, start, end, inp):
    if start == end:
        Tree[root] = input[start]
        return Tree[root]

    mid = start + (end - start) / 2
    leftMin = buildTree(
      root * 2 + 1, Tree, start, mid, inp)
    rightMin = buildTree(
      root * 2 + 2, Tree, mid + 1, end, inp)
    Tree[root] = min(leftMin, rightMin)
    return Tree[root]

def rangeQUtil(root, Tree, start, end, qs, qe):
    if qe < start or qs > end:
        return float("inf")

    if qs <= start and qe >= end:
        return Tree[root]

    int mid = start + (end - start) / 2
    int leftMin = rangeQUtil(
      root * 2 + 1, Tree, start, mid, qs, qe)
    int rightMin = rangeQUtil(
      root * 2 + 2, Tree, mid + 1, end, qs, qe)
    return min(leftMin, rightMin)

# Initialize
inp = [0,1,2,3,4,5,6,7,8,9]
tr = [-1 for x in range(len(input)*2+1)]
tr = buildTree(0, tr, 0, len(input)-1, inp)

# Query
n = len(inp) - 1; qstart = 0; qend = 5
rangeQUtil(0, tr, 0, n, qstart, qend)
\end{minted}

\section{Dijkstra}

\begin{minted}{python}
def dijkstra_search(graph, start, goal):
  frontier = PriorityQueue()
  frontier.put(start, 0)
  came_from = {}
  cost_so_far = {}
  came_from[start] = None
  cost_so_far[start] = 0

  while not frontier.empty():
    current = frontier.get()

    if current == goal:
      break

    for next in graph.neighbors(current):
      new_cost = cost_so_far[current] \
        + graph.cost(current, next)

      if next not in cost_so_far or \
        new_cost < cost_so_far[next]:

        cost_so_far[next] = new_cost
        priority = new_cost
        frontier.put(next, priority)
        came_from[next] = current

  return came_from, cost_so_far
\end{minted}

\section{Breath-First Search}

% http://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/

Graphe de référence

\begin{minted}{python}
graph = {'A': set(['B', 'C']),
         'B': set(['A', 'D', 'E']),
         'C': set(['A', 'F']),
         'D': set(['B']),
         'E': set(['B', 'F']),
         'F': set(['C', 'E'])}
\end{minted}

Composantes connexes (tous les points connectés à ce noeud)

\begin{minted}{python}
def bfs(graph, start):
  visited, queue = set(), [start]
  while queue:
    vertex = queue.pop(0)
    if vertex not in visited:
      visited.add(vertex)
      queue.extend(graph[vertex] - visited)
  return visited

bfs(graph, 'A')
# {'B', 'C', 'A', 'F', 'D', 'E'}
\end{minted}

Recherche de chemins

\begin{minted}{python}
def bfs_paths(graph, start, goal):
  queue = [(start, [start])]
  while queue:
    (vertex, path) = queue.pop(0)
    for next in graph[vertex] - set(path):
      if next == goal:
        yield path + [next]
      else:
        queue.append((next, path + [next]))

list(bfs_paths(graph, 'A', 'F')) 
# [['A', 'C', 'F'], ['A', 'B', 'E', 'F']]
\end{minted}

\section{Tableaux ASCII}

Lettres minuscules

\begin{tabular}{c|c||c|c||c|c}
\hline
dec & char & dec & char & dec & char\\
\hline
97  & a & 106 & j & 115 & s \\
98  & b & 107 & k & 116 & t \\
99  & c & 108 & l & 117 & u \\
100 & d & 109 & m & 118 & v \\
101 & e & 110 & n & 119 & w \\
102 & f & 111 & o & 120 & x \\
103 & g & 112 & p & 121 & y \\
104 & h & 113 & q & 122 & z \\
105 & i & 114 & r &     &   \\
\hline
\end{tabular}

Lettres majuscules

\begin{tabular}{c|c||c|c||c|c}
\hline
dec & char & dec & char & dec & char\\
\hline
65 & A & 74 & J & 83 & S \\
66 & B & 75 & K & 84 & T \\
67 & C & 76 & L & 85 & U \\
68 & D & 77 & M & 86 & V \\
69 & E & 78 & N & 87 & W \\
70 & F & 79 & O & 88 & X \\
71 & G & 80 & P & 89 & Y \\
72 & H & 81 & Q & 90 & Z \\
73 & I & 82 & R &     &   \\

\hline
\end{tabular}

\section{Algorithmes}

ROT N

\subsection{Génération de nombres premiers}

Dynamic erathostene

\begin{minted}{python}

primes = [2, 3]

def bumblebee(n):
    prime = True
    i = primes[-1]
    while primes[-1] < n:
        prime = True
        for p in primes:
            if i % p == 0:
                prime = False
                break
        if prime:
            primes.append(i)
        i += 2
\end{minted}

% You can even have references
\rule{0.3\linewidth}{0.25pt}
\scriptsize
\bibliographystyle{abstract}
\bibliography{refFile}
\end{multicols}
\end{document}
